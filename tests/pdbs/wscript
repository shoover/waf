# Compile and link several independent targets at once, which can
# generate a link warning that the PDB file is not found with the
# object.
#
# Increase the number of jobs and tests to see the warning. Increase
# the sleep to see it go away.
#
#    waf -j16 --n 20 --sleep 0


from waflib import Task

def options(opt):
    opt.add_option('--sleep',
                   action = 'store',
                   type = 'float',
                   default = 0.0,
                   dest = 'sleep',
                   help = 'Set the sleep time before each link task.')
    opt.add_option('--n',
                   action = 'store',
                   type = 'int',
                   default = 10,
                   dest = 'n_tests',
                   help = 'Set the number of programs to build.')

    opt.load('compiler_c')

def configure(conf):
    conf.load('compiler_c')
    conf.env.append_value('CFLAGS', ['/Zi', '/FS', '/MDd'])
    conf.env.append_value('LINKFLAGS', ['/DEBUG', '/MANIFEST', '/INCREMENTAL:NO'])

def build(bld):
    Task.classes['link'].ext_in.append('.o')

    for t in range(0, bld.options.n_tests):
        bld(features = 'c cprogram',
            source = ['b.c'],
            target = 'test%d' % t,

            # setting a unique PDB file solves the problem
            #cflags = bld.env.CFLAGS + ['/FdvcTest%s' % t],

            # setting a sleep somewhere in the build order can solve
            # the problem, if forced before any link starts (see
            # sleep_task below)
            sleep = bld.options.sleep)


from waflib import TaskGen
@TaskGen.feature('c')
def sleep_if_set(self):
    t = getattr(self, 'sleep', 0.0)
    if t > 0:
        self.create_task('sleep')

class sleep_task(Task.Task):
    # with no extension constraints, sleeps and links are interleaved
    # and the warning can occur

    #ext_in = '.bin'       # force sleeps after all links complete
    ext_out = '.o'         # force all sleeps before any link starts

    def run(self):
        import time
        time.sleep(self.generator.sleep)
        return 0


@TaskGen.feature('c', 'cxx')
@TaskGen.after_method('apply_link')
def propagate_compiler_debug_symbols(self):
    """For msvc, determine the implicit or explicit PDB for each source
    file configured to generate debug info. These files become
    compiler outputs and link task dependencies (though we do not have
    to pass them in the LINKFLAGS). Tracking them is needed to
    constrain the build order if there are multiple targets building
    in one directory and some link tasks may proceed while otherwise
    unrelated compiler instances are still writing debug info to the
    same file.
    """
    if self.env.CC_NAME != 'msvc' or not getattr(self, 'link_task', None):
	return

    try:
        pdbs = getattr(self.link_task, 'pdbs', [])
    except AttributeError:
        pdbs = self.link_task.pdbs = []

    for t in getattr(self, 'compiled_tasks', []):
        pdb = None
	for f in t.env['CFLAGS']:
	    d = f.lower()

	    if d[1:] == 'zi':
                # /Zi or /ZI generate compiler PDBs, which might be implicit
                if not pdb:
                     msvc_ver = str(self.env['MSVC_VERSION']).replace('.', '')
                     pdb = 'vc%s' % msvc_ver
            elif d[1:3] == 'fd':
                # /FdFILE specifies a file name or directory
                # TODO: handle the directory case
                pdb = f[3:]

        if pdb:
            print 'taskgen', self.target, ' depends on task ', t, ' pdb=', pdb

            node = self.path.find_or_declare(pdb + '.pdb')
            t.outputs.append(node)
            if not node in self.link_task.dep_nodes:
                self.link_task.dep_nodes.append(node)
