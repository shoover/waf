# Compile and link several independent targets at once, which can
# generate a link warning that the PDB file is not found with the
# object.
#
# Increase the number of jobs and tests to see the warning. Uncomment the taskgen
# method or provide unique pdbs to make it go away.
#
#    waf -j16 --n 20


# Two different taskgen methods are shown. The first version creates a unique PDB per
# object file and can also parse a file or directory from the /Fd flag, if present in
# tsk.env.CFLAGS.
#
# There is code in place to create file dependencies between compile and link tasks
# because technically the object pdb is read by the linker. In practice it is unnecessary
# if unique names are used and errorprone if files are shared (waf's error checker flags
# multiple compile tasks writing the same output).
#
# The second version generates a unique pdb per target. It is simple and sufficient.
#
# Other options outside of waf include:
#
# * use the /Z7 flag to embed debug info in the object files
# * use /Zi or /ZI and the default pdb but place each target in its own folder with
#   recursive wscripts

from waflib import Logs, Task, TaskGen
from waflib.Logs import info
import os

def options(opt):
	opt.add_option('--n', action = 'store', type = 'int', default = 10,
		dest = 'n_tests', help = 'Set the number of programs to build.')
	opt.add_option('--unique', action = 'store', default = 'target',
		dest = 'unique', help = 'Unique pdb per "target" or "object"')
	opt.load('compiler_c')

def configure(conf):
	conf.load('compiler_c')

	if conf.env.CC_NAME == 'msvc':
		conf.env.append_value('CFLAGS', ['/Zi', '/FS', '/MDd'])
		conf.env.append_value('LINKFLAGS', ['/DEBUG'])

def build(bld):
	for t in range(0, bld.options.n_tests):
		# multiple targets to simulate concurrent compiling and linking
		bld(features = 'c cprogram',
		    # Multiple sources to force concurrent compiling per target.
		    source = ['a.c',
			      'b.c'],
		    target = 'test%d' % t,
		    # No /Fd flag given in CFLAGS, the tool generates a unique pdb.
		    )

	bld(features = 'c cprogram',
	    source = ['a.c', 'b.c'],
	    target = 'test-pdb-base',
	    # you can pass a pdb base name
	    cflags = '/Fdexplicit-vc-base')

	bld(features = 'c cprogram',
	    source = ['a.c', 'b.c'],
	    target = 'test-pdb-explicit',
	    # you can pass a file name with extension
	    cflags = '/Fdexplicit-vc.pdb_not')

	pdb_folder = bld.bldnode.make_node('pdbs')
	pdb_folder.mkdir()
	bld(features = 'c cprogram',
	    source = ['a.c', 'b.c'],
	    target = 'test-pdb-folder',
	    # you can pass a folder\ and a default pdb will be generated there
	    cflags = ('/Fd%s%s' % (pdb_folder.name, os.sep)))

@TaskGen.feature('c', 'cxx')
@TaskGen.after_method('apply_link', 'process_source')
def propagate_compiler_debug_symbols(self):
	"""For msvc, check if a PDB is given for each source file (tsk.env.CFLAGS), and if not add
	a flag to generate one.

	If no file is specified, a unique pdb is generated, to prevent the following link
	warning if multiple targets build in the same directory with the implied default
	pdb (vcVER.pdb):

            LNK4099: PDB 'vc140.pdb' was not found with 'test.c.2.o'...
            linking object as if no debug info

	The issue is that one target may be compiling and writing the object pdb while an
	independent target begins linking and reading the same file. This can happen, for
	example, with multiple test programs located in one directory. msbuild projects
	would work around this by using different project folders for each program. Or a
	unique pdb file per object file may be used via the flag /Fd. In practice, using
	one pdb per target (along with the flag /FS if there are multiple source files in
	the target) is sufficient to control concurrent access between compile and link
	tasks.

	"""
	if self.env.CC_NAME != 'msvc' or self.bld.options.unique != 'object':
		return

	link_task = getattr(self, 'link_task', None)

	explicit = []

	for t in getattr(self, 'compiled_tasks', []):
		# Search CFLAGS for debug flags.
		fd = None
		debug = False
		for f in t.env['CFLAGS']:
			d = f.lower()

			if d[1:] == 'zi':
				# /Zi or /ZI enable debug info
				debug = True
			elif d[1:3] == 'fd':
				# /FdFILE, if present, specifies a pdb
				# base name, file name with extension,
				# or directory
				fd = f[3:]

		if not debug:
			continue

		if fd:
			if fd.endswith(os.sep):
				# If CFLAGS specifies /FdFOLDER\, we will generate the
				# msvc-default vcVER.pdb.
				msvc_ver = str(self.env['MSVC_VERSION']).replace('.', '')
				pdb = 'vc%s.pdb' % msvc_ver
				name = fd + pdb
			else:
				# /FdFILE or /FdFILE.EXT. Add the extension since we need
				# it for the node.
				base, ext = os.path.splitext(fd)
				name = fd if ext else fd + '.pdb'

			node = self.path.find_or_declare(name)
		else:
			# If no /Fd is given, generate a unique name based on the object
			# file and update the flags.
			node = t.outputs[0].change_ext('.pdb')
			t.env.append_value('CFLAGS', '/Fd%s' % node.name)

		info("target %s, source %s, pdb=%s" % (self.get_name(), t, node.relpath()))

		# To be pedantic, we might create pdb file dependencies between the
		# compile and link tasks, which would orchestrate the build successfully
		# even if all compile tasks were writing a single common object pdb (not
		# the recommended mode), but it is unclear which tasks must be run if the
		# pdb is removed.

		# Indeed, waf -v warns that the node if created twice if
		# we get a pdb file from the taskgen's CFLAGS and apply it to multiple
		# compile task outputs.
		#
		# t.outputs.append(node)

		if link_task and not node in link_task.dep_nodes:
			link_task.dep_nodes.append(node)

@TaskGen.feature('c', 'cxx')
@TaskGen.after_method('process_source')
def apply_unique_pdb_per_target(self):
	"""For msvc, specify a unique compile pdb per target, to work around
	LNK4099 in case multiple independent targets build in the same
	directory, e.g. test programs. CFLAGS are updated with a unique
	/Fd flag based on the target name. This is separate from the link pdb.
	"""
	if self.env.CC_NAME != 'msvc' or self.bld.options.unique != 'target':
		return

	debug = False
	fd = False
	for f in self.env['CFLAGS']:
		fl = f.lower()
		if fl[1:].lower() == 'zi': # /Zi, /ZI enable debug
			debug = True
		elif fl[1:3] == 'fd':	   # /Fd, file or directory already provided
			fd = True

	if debug and not fd:
		# The .vc.pdb extension makes the file different than the default link
		# pdb. It actually seems to work if you let them conflict, but who knows
		# if that's a good idea.
		pdb = "%s.vc.pdb" % self.get_name()
		self.env.append_value('CFLAGS', '/Fd%s' % pdb)
